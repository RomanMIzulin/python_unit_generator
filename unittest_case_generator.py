import inspect
import os
 
from dataclasses import dataclass
from typing import Any, Callable, TypeVar, ParamSpec, NamedTuple


ReturnType = TypeVar("ReturnType")  # the callable/awaitable return type
Param = ParamSpec("Param")  # the callable parameters



class NotFullyTypedError(Exception):
    """Raised when a function is not fully typed."""

    pass



def generate_test_case(func: Callable[Param, ReturnType]) -> str: # type: ignore
    sig: inspect.Signature = inspect.signature(func)

    # check if all parameters are annotated
    for param in sig.parameters.values():
        if param.annotation is inspect.Parameter.empty:
            raise NotFullyTypedError(
                f"Parameter '{param.name}' of function '{func.__name__}' is not typed"
            )
    # Check if return type is annotated
    if sig.return_annotation is inspect.Signature.empty:
        raise NotFullyTypedError(f"Return type of function '{func.__name__}' is not typed")
    
    func_name = func  # ugly hack

    def test_func():

        class Args(NamedTuple):
            ...

        class Test:
            name: str
            args: Args
            want: ReturnType

        cases: tuple[Test] = (  # type: ignore
            # TODO: add cases here
        )
        
        print(f"running test cases for func_name function:\n")
        for case in cases:
            if (v := func(*case.args)) != case.want:  # type: ignore
                print(f"{case.name} func_name got {v} wanted {case.want}")
        print('Test complited')
    test_func.__name__ = f"test_{func.__name__}"

    args_txt = ""
    cnt = 0
    for _, v in sig.parameters.items():
        if cnt != 0:
            args_txt += " " * 12 + str(v) + "\n"
        else:
            args_txt = str(v) + "\n"
            cnt += 1

    res = (
        inspect.getsource(test_func)
        .replace("  # type: ignore", "")
        .replace("test_func", f"test_{func.__name__}")
        .replace("func_name", f"{func.__name__}")
        .replace("ReturnType", sig.return_annotation.__name__)
        .replace("...", args_txt)
    )
    tmp = res.splitlines(keepends=True)
    final_res = ""
    for line in tmp:
        final_res += line[4:] if len(line) > 4 else line
    return final_res

def save_to_file(func: Callable[Param, Any], file_path: str| None):
    # by default to the same directory where funtion is defined
    if file_path is None:
        file_path = inspect.getfile(func).replace(".py", "_test.py")
    if os.path.isfile(file_path):
        # TODO: read file, count number of test cases, add new test case
        return
    with open(file_path, "w") as f:
        f.write('"""This file is generated by test_case_generator"""\n')
        f.write("from typing import NamedTuple\n\n")
        f.write(f'from {inspect.getfile(func).replace(".py", "").split("/")[-1]} import {func.__name__}\n\n')
        f.write(generate_test_case(func))

def append_to_file(file_path: str, func: Callable[Param, Any]):
    with open(file_path, "a") as f:
        f.write("\n\n")
        f.write(generate_test_case(func))



if __name__ == "__main__":

    def kek(foo: int, bar: str) -> str:
        return str(foo) + bar

    print(generate_test_case(kek))
    print(generate_test_case(generate_test_case))
    save_to_file(generate_test_case, "test.py")
