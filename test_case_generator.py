import inspect
import os
from typing import Callable, NamedTuple


class NotFullyTypedError(Exception):
    """Raised when a function is not fully typed."""

    pass


def generate_test_case(func: Callable) -> str:
    sig: inspect.Signature = inspect.signature(func)

    # check if all parameters are annotated
    for param in sig.parameters.values():
        if param.annotation is inspect.Parameter.empty:
            raise NotFullyTypedError(
                f"Parameter '{param.name}' of function '{func.__name__}' is not typed"
            )
    # Check if return type is annotated
    if sig.return_annotation is inspect.Signature.empty:
        raise NotFullyTypedError(f"Return type of function '{func.__name__}' is not typed")
    
    func_name = func  # ugly hack

    def test_func():
        class Args(NamedTuple):
            args_here  # type: ignore
        class Test(NamedTuple):
            name: str
            args: Args
            want: output_type  # type: ignore

        cases: tuple[Test] = (  # type: ignore
            # TODO: add cases here
        )
        print(f"running test cases for func_name function:\n")
        for case in cases:
            if (v := func_name(*case.args)) != case.want:
                print(f"{case.name} func_name got {v}, wanted: {case.want}\n")
        print('Test complited')

    args_txt = ""
    cnt = 0
    for _, v in sig.parameters.items():
        if cnt != 0:
            args_txt += " " * 12 + str(v) + "\n"
        else:
            args_txt = str(v) + "\n"
            cnt += 1

    res = (
        inspect.getsource(test_func)
        .replace("  # type: ignore", "")
        .replace("test_func", f"test_{func.__name__}")
        .replace("func_name", f"{func.__name__}")
        .replace("output_type", sig.return_annotation.__name__)
        .replace("args_here", args_txt)
    )
    tmp = res.splitlines(keepends=True)
    final_res = ""
    for line in tmp:
        final_res += line[4:] if len(line) > 4 else line
    return final_res



def save_to_file(func, file_path: str | None):
    # by default to the same directory where funtion is defined
    if file_path is None:
        file_path = inspect.getfile(func).replace(".py", "_test.py")
    if os.path.isfile(file_path):
        # TODO: read file, count number of test cases, add new test case
        return
    with open(file_path, "w") as f:
        f.write('"""This file is generated by test_case_generator"""\n')
        f.write("from typing import NamedTuple\n\n")
        f.write(f'from {inspect.getfile(func).replace(".py", "").split("/")[-1]} import {func.__name__}\n\n')
        f.write(generate_test_case(func))


def append_to_file(file_path: str, func):
    with open(file_path, "a") as f:
        f.write("\n\n")
        f.write(generate_test_case(func))


if __name__ == "__main__":

    def kek(arg1: int, arg2: str) -> str:
        return str(arg1) + arg2

    print(generate_test_case(kek))
    print(generate_test_case(generate_test_case))
    save_to_file(generate_test_case, "test.py")
